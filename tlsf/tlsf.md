# TLSF算法详解
### 什么是TLSF
- TLSF的全称 **Two-Level Segregated Fit**。
> **Segregated Fit（分级隔离）**：将空闲内存块按照大小分到不同的“组”（Class）里。申请内存时，先确定它属于哪个组，然后只在这个组里寻找。
> **Two-Level（两级）**：分组的过程分为两级，像查二维表格一样，实现快速、精确的定位。

### TLSF的作用
- TLSF是一种内存管理算法，据有内存分配快，内存碎片小的特点，个人认为非常适用于嵌入式系统。

### TLSF的实现
#### 内存分组
- 首先是一级分组**FLI（First Level Index）**：按照内存块大小来划分  
首先把内存分成[2^4-2^5),[2^5-2^6),[2^6-2^7)...的大小块(含头不含尾)。其中最低大小是2^4个字节  
假如现在要申请20个字节，那么在[2^4-2^5)这个区间，就是第0组(FLI = 0),假如要申请100个字节，那么在[2^6-2^7)之间，就是第2组(FLI = 2)

- **注意**这样分组太粗了，会导致严重的内存浪费
 
- 二级分组它来了**SLI（Second Level Index）**：对一级分组的内存块再做区分。  
一级分组的最小块是2^4-2^5,16-32字节，这个区间的跨度是32-16=16字节。  
这样再把数据分成16分，可以用来申请16字节到32字节之间的任意大小而不造成浪费。  
16 = 2^4。这里把SLI_COUNT定义成4，就是2^4 = 16。  
比如我要申请100个字节，按照一级分区得出FLI等于2，在[2^6-2^7)64-128字节中，这个区间的跨度128-64 = 64字节，由于SLI_COUNT = 4，那么64 / (2^4) = 4，这个跨度区间又被分成16个小分，每分4个字节。100 - 64 = 36，36 / 4 = 9，所以100个字节在第二次分组的时候分在了第9组(含头不含尾),SLI = 9。

#### 数据结构——Bitmap  

- TLSF使用了两级位图：
第一级位图（fl_bitmap）：​ 一个整数（如32位），它的第 i位为1，表示在第一级i这个组里，至少有一个二级链表是非空的。

- 第二级位图（sl_bitmap[i]）：​ 一个整数数组，每个元素对应一个第一级组。sl_bitmap[i]的第 j位为1，表示在单元格 (i， j)对应的链表是非空的。

- 假设现在有512字节的连续内存，可以用来申请，对应的范围是[2^9， 2^10),那么FLI + 4 = 9，FLI = 5，512个字节刚好落在[2^9， 2^10)区间的头部，那么SLI = 0。对应状态：​ list[5][0]中有一个512字节的空闲块。fl_bitmap第5位置1，sl_bitmap[5]第0位置1。

- 如果现在要在512字节的空闲内存中申请100字节，100字节在[64，128)范围内，计算得到FLI = 2，SLI = 9。查找Bitmap，在fl_bitmap中的第FLI位（也就是第2位）开始查找，发现第5位bit为1，再到sl_bitmap[5]中查找发现第0位是1，那么就从这个list[5][0]取出100字节，这100字节加上数据结构的一些属性比如数据块的头，尾等(假设8个字节)，那么实际使用掉的就是108个字节，这样还剩下512 - 108 = 404个字节空闲块。404个字节在[2^8， 2^9)区间内，计算得到FLI为4，SLI为9，对应新的空闲块list[4][9]。最后更新对应的Bitmap。

- 在释放内存的时候先检查前后块的内存是否空闲并且物理地址是否连续，如果是责把前后空闲块一起合并进来组成一个大的空闲块，然后更新Bitmap，这样能减少内存碎片。

### 总结
- TLSF算法通过其精妙的二维分层索引（FLI/SLI）和位图机制，将寻找空闲内存块的操作用直接索引的方式来查找，完美满足了实时系统的确定性要求。同时，通过在释放内存时积极地与相邻空闲块合并，有效地减少了内存碎片。

- 喜欢的朋友关注微信订阅号 **CoderPark**
